
## 作业1：总结几种粘包方式
以"hello world"为例
转换为2进制为：

01101000
01100101
01101100
01101100
01101111
00100000
01110111
01101111
01110010
01101100
01100100

共11个字节（byte ）


### fix length
以固定字节长度 编码/解码

以上面"hello world" 为例，假设以6字节为固定长度粘包

发送端实际上应该发送"hello world "的包，多出来的" "是补位的

而接受端，接收到的就是"hello " 和"world "2个包

优点：实现简单，只按长度粘包拆包效率高

缺点：包长度不好定义，定义长了浪费空间，定义短了一个包无法完整包含数据

适用与固定长度的消息传递

### delimiter based 
以分隔符 编码/解码

以上面"hello world" 为例，假设以" "字符为delimiter粘包

发送端发送"hello world "的包

而接受端，接收到的就是"hello" 和"world"2个包

中间和最后的2个" "会被当作分隔符，不会做为解码后的数据

优点：实现简单，效率相对较高

缺点：如果被编码的数据包含原本就包含分割符，需要对分隔符转译，否则解码的结果会与预想不同


### length field based frame decoder
自定义长度帧 编码/解码
通过一个定长的字节记录数据包长度，再加上数据包组成：
length+body

举例：
可以定义一个字节：表示包长度（一个字节8bit位，最长可表示255）
我们的数据包都长度都不超过255个字节就可以了

还是以"hello world"这个包位例子
包内容长度位11个字节

那么编码：

就将11这个int 转换为 一个字节 00001011

将包内容"hello world"转为二进制
01101000
01100101
01101100
01101100
01101111
00100000
01110111
01101111
01110010
01101100
01100100

解码：

先定长的获取1字节 00001011 转换为int = 11

再读取11个字节，转换为字符串，就是完整的包"hello world"

注释：1个字节只能表示0-255长度的包长，实际生产可用4字节或更长，主要决定与包长度

优点：可以更灵活的编解码

比如自定义协议：

前n个字节定义header的长度， 然后跟着header信息

再m个字节定义body的长度，后面跟着body的信息

缺点：实现比上面两种复杂


## 作业2：实现一个从socket connection 解码goim的协议解析器

